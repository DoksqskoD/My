# Задача 2
# Даны списки:
#
# a = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89];
#
# b = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13].
#
# Нужно вернуть список, который состоит из элементов, общих для этих двух списков.

import numpy

The_first_option = False
The_second_option = False
The_third_option = True

#Мой первый вариант
#_______________________________________________________________________________________

def Arrays_A_B(a : list,b : list, option = [False, False, False]) -> None:
    if option[0]:
        a_copy = numpy.array(a.copy())
        b_copy = numpy.array(b.copy())
        print(numpy.intersect1d(a_copy, b_copy))

#Мой второй вариант
#_______________________________________________________________________________________

    if option[1]:
        print(numpy.intersect1d(numpy.array(a.copy()), numpy.array(b.copy())))

#Мой третий вариант
# _______________________________________________________________________________________

    if option[2]:
        a_copy = numpy.array(a.copy())
        b_copy = numpy.array(b.copy())
        print(set([z for z in a_copy if z  in b_copy]))

if __name__ == "__main__":
    a = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
    b = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]
    Arrays_A_B(a=a, b=b, option = [The_first_option, The_second_option, The_third_option])

#Первый вариант решения от сайта
#_______________________________________________________________________________________

# Можем воспользоваться функцией filter:

a = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
b = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]

result = list(filter(lambda elem: elem in b, a))

#Второй вариант решения от сайта
#_______________________________________________________________________________________

# Или списковым включением:

result = [elem for elem in a if elem in b]

#Третий вариант решения от сайта
#_______________________________________________________________________________________

# А можно привести оба списка к множествам и найти их пересечение:

result = list(set(a) & set(b))

# Однако в таком случае каждый элемент встретится в результирующем списке лишь один раз,
# т.к. множество поддерживает уникальность входящих в него элементов. Первые два решения
# (с фильтрацией) оставят все дубли на своих местах.